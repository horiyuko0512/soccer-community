/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
  /** The builtin Time type */
  Time: { input: any; output: any; }
};

/**
 * CreateMatchInput is used for create Match object.
 * Input was generated by ent.
 */
export type CreateMatchInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  creatorID: Scalars['ID']['input'];
  date: Scalars['Time']['input'];
  fee: Scalars['Int']['input'];
  isApplied?: InputMaybe<Scalars['Boolean']['input']>;
  level: MatchLevel;
  location: Scalars['String']['input'];
  matchParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  notes: Scalars['String']['input'];
  participants: Scalars['Int']['input'];
  title: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateParticipationInput is used for create Participation object.
 * Input was generated by ent.
 */
export type CreateParticipationInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  matchID: Scalars['ID']['input'];
  status?: InputMaybe<ParticipationStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  email: Scalars['String']['input'];
  introduction: Scalars['String']['input'];
  matchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  nickname: Scalars['String']['input'];
  passwordHash: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Match = Node & {
  __typename?: 'Match';
  createdAt: Scalars['Time']['output'];
  creator: User;
  creatorID: Scalars['ID']['output'];
  date: Scalars['Time']['output'];
  fee: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  isApplied: Scalars['Boolean']['output'];
  level: MatchLevel;
  location: Scalars['String']['output'];
  matchParticipation?: Maybe<Array<Participation>>;
  notes: Scalars['String']['output'];
  participants: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** MatchLevel is enum for the field level */
export enum MatchLevel {
  Advanced = 'advanced',
  Beginner = 'beginner',
  Intermediate = 'intermediate'
}

/**
 * MatchWhereInput is used for filtering Match objects.
 * Input was generated by ent.
 */
export type MatchWhereInput = {
  and?: InputMaybe<Array<MatchWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** creator_id field predicates */
  creatorID?: InputMaybe<Scalars['ID']['input']>;
  creatorIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  creatorIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  creatorIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** date field predicates */
  date?: InputMaybe<Scalars['Time']['input']>;
  dateGT?: InputMaybe<Scalars['Time']['input']>;
  dateGTE?: InputMaybe<Scalars['Time']['input']>;
  dateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateLT?: InputMaybe<Scalars['Time']['input']>;
  dateLTE?: InputMaybe<Scalars['Time']['input']>;
  dateNEQ?: InputMaybe<Scalars['Time']['input']>;
  dateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** fee field predicates */
  fee?: InputMaybe<Scalars['Int']['input']>;
  feeGT?: InputMaybe<Scalars['Int']['input']>;
  feeGTE?: InputMaybe<Scalars['Int']['input']>;
  feeIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  feeLT?: InputMaybe<Scalars['Int']['input']>;
  feeLTE?: InputMaybe<Scalars['Int']['input']>;
  feeNEQ?: InputMaybe<Scalars['Int']['input']>;
  feeNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** creator edge predicates */
  hasCreator?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatorWith?: InputMaybe<Array<UserWhereInput>>;
  /** match_participation edge predicates */
  hasMatchParticipation?: InputMaybe<Scalars['Boolean']['input']>;
  hasMatchParticipationWith?: InputMaybe<Array<ParticipationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_applied field predicates */
  isApplied?: InputMaybe<Scalars['Boolean']['input']>;
  isAppliedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** level field predicates */
  level?: InputMaybe<MatchLevel>;
  levelIn?: InputMaybe<Array<MatchLevel>>;
  levelNEQ?: InputMaybe<MatchLevel>;
  levelNotIn?: InputMaybe<Array<MatchLevel>>;
  /** location field predicates */
  location?: InputMaybe<Scalars['String']['input']>;
  locationContains?: InputMaybe<Scalars['String']['input']>;
  locationContainsFold?: InputMaybe<Scalars['String']['input']>;
  locationEqualFold?: InputMaybe<Scalars['String']['input']>;
  locationGT?: InputMaybe<Scalars['String']['input']>;
  locationGTE?: InputMaybe<Scalars['String']['input']>;
  locationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  locationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  locationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  locationLT?: InputMaybe<Scalars['String']['input']>;
  locationLTE?: InputMaybe<Scalars['String']['input']>;
  locationNEQ?: InputMaybe<Scalars['String']['input']>;
  locationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<MatchWhereInput>;
  /** notes field predicates */
  notes?: InputMaybe<Scalars['String']['input']>;
  notesContains?: InputMaybe<Scalars['String']['input']>;
  notesContainsFold?: InputMaybe<Scalars['String']['input']>;
  notesEqualFold?: InputMaybe<Scalars['String']['input']>;
  notesGT?: InputMaybe<Scalars['String']['input']>;
  notesGTE?: InputMaybe<Scalars['String']['input']>;
  notesHasPrefix?: InputMaybe<Scalars['String']['input']>;
  notesHasSuffix?: InputMaybe<Scalars['String']['input']>;
  notesIn?: InputMaybe<Array<Scalars['String']['input']>>;
  notesLT?: InputMaybe<Scalars['String']['input']>;
  notesLTE?: InputMaybe<Scalars['String']['input']>;
  notesNEQ?: InputMaybe<Scalars['String']['input']>;
  notesNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  or?: InputMaybe<Array<MatchWhereInput>>;
  /** participants field predicates */
  participants?: InputMaybe<Scalars['Int']['input']>;
  participantsGT?: InputMaybe<Scalars['Int']['input']>;
  participantsGTE?: InputMaybe<Scalars['Int']['input']>;
  participantsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  participantsLT?: InputMaybe<Scalars['Int']['input']>;
  participantsLTE?: InputMaybe<Scalars['Int']['input']>;
  participantsNEQ?: InputMaybe<Scalars['Int']['input']>;
  participantsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createMatch: Match;
  createParticipation: Participation;
  createUser: User;
  login: Scalars['String']['output'];
  updateMatch: Match;
  updateParticipation: Participation;
  updateUser: User;
};


export type MutationCreateMatchArgs = {
  input: CreateMatchInput;
};


export type MutationCreateParticipationArgs = {
  input: CreateParticipationInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationLoginArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationUpdateMatchArgs = {
  id: Scalars['ID']['input'];
  input: UpdateMatchInput;
};


export type MutationUpdateParticipationArgs = {
  id: Scalars['ID']['input'];
  input: UpdateParticipationInput;
};


export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Participation = Node & {
  __typename?: 'Participation';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  match: Match;
  matchID: Scalars['ID']['output'];
  status: ParticipationStatus;
  updatedAt: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/** ParticipationStatus is enum for the field status */
export enum ParticipationStatus {
  Approved = 'approved',
  Cancelled = 'cancelled',
  Pending = 'pending',
  Rejected = 'rejected'
}

/**
 * ParticipationWhereInput is used for filtering Participation objects.
 * Input was generated by ent.
 */
export type ParticipationWhereInput = {
  and?: InputMaybe<Array<ParticipationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** match edge predicates */
  hasMatch?: InputMaybe<Scalars['Boolean']['input']>;
  hasMatchWith?: InputMaybe<Array<MatchWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** match_id field predicates */
  matchID?: InputMaybe<Scalars['ID']['input']>;
  matchIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  matchIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  matchIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ParticipationWhereInput>;
  or?: InputMaybe<Array<ParticipationWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<ParticipationStatus>;
  statusIn?: InputMaybe<Array<ParticipationStatus>>;
  statusNEQ?: InputMaybe<ParticipationStatus>;
  statusNotIn?: InputMaybe<Array<ParticipationStatus>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Query = {
  __typename?: 'Query';
  matche: Match;
  matches: Array<Match>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  participation: Participation;
  participations: Array<Participation>;
  user: User;
  users: Array<User>;
};


export type QueryMatcheArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryParticipationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};

/**
 * UpdateMatchInput is used for update Match object.
 * Input was generated by ent.
 */
export type UpdateMatchInput = {
  addMatchParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearMatchParticipation?: InputMaybe<Scalars['Boolean']['input']>;
  creatorID?: InputMaybe<Scalars['ID']['input']>;
  date?: InputMaybe<Scalars['Time']['input']>;
  fee?: InputMaybe<Scalars['Int']['input']>;
  isApplied?: InputMaybe<Scalars['Boolean']['input']>;
  level?: InputMaybe<MatchLevel>;
  location?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  participants?: InputMaybe<Scalars['Int']['input']>;
  removeMatchParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateParticipationInput is used for update Participation object.
 * Input was generated by ent.
 */
export type UpdateParticipationInput = {
  matchID?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ParticipationStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addMatchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearMatches?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserParticipation?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  introduction?: InputMaybe<Scalars['String']['input']>;
  nickname?: InputMaybe<Scalars['String']['input']>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  removeMatchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserParticipationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  createdAt: Scalars['Time']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  introduction: Scalars['String']['output'];
  matches?: Maybe<Array<Match>>;
  nickname: Scalars['String']['output'];
  passwordHash: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  userParticipation?: Maybe<Array<Participation>>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** matches edge predicates */
  hasMatches?: InputMaybe<Scalars['Boolean']['input']>;
  hasMatchesWith?: InputMaybe<Array<MatchWhereInput>>;
  /** user_participation edge predicates */
  hasUserParticipation?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserParticipationWith?: InputMaybe<Array<ParticipationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** introduction field predicates */
  introduction?: InputMaybe<Scalars['String']['input']>;
  introductionContains?: InputMaybe<Scalars['String']['input']>;
  introductionContainsFold?: InputMaybe<Scalars['String']['input']>;
  introductionEqualFold?: InputMaybe<Scalars['String']['input']>;
  introductionGT?: InputMaybe<Scalars['String']['input']>;
  introductionGTE?: InputMaybe<Scalars['String']['input']>;
  introductionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  introductionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  introductionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  introductionLT?: InputMaybe<Scalars['String']['input']>;
  introductionLTE?: InputMaybe<Scalars['String']['input']>;
  introductionNEQ?: InputMaybe<Scalars['String']['input']>;
  introductionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** nickName field predicates */
  nickname?: InputMaybe<Scalars['String']['input']>;
  nicknameContains?: InputMaybe<Scalars['String']['input']>;
  nicknameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nicknameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nicknameGT?: InputMaybe<Scalars['String']['input']>;
  nicknameGTE?: InputMaybe<Scalars['String']['input']>;
  nicknameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nicknameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nicknameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nicknameLT?: InputMaybe<Scalars['String']['input']>;
  nicknameLTE?: InputMaybe<Scalars['String']['input']>;
  nicknameNEQ?: InputMaybe<Scalars['String']['input']>;
  nicknameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** password_hash field predicates */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  passwordHashContains?: InputMaybe<Scalars['String']['input']>;
  passwordHashContainsFold?: InputMaybe<Scalars['String']['input']>;
  passwordHashEqualFold?: InputMaybe<Scalars['String']['input']>;
  passwordHashGT?: InputMaybe<Scalars['String']['input']>;
  passwordHashGTE?: InputMaybe<Scalars['String']['input']>;
  passwordHashHasPrefix?: InputMaybe<Scalars['String']['input']>;
  passwordHashHasSuffix?: InputMaybe<Scalars['String']['input']>;
  passwordHashIn?: InputMaybe<Array<Scalars['String']['input']>>;
  passwordHashLT?: InputMaybe<Scalars['String']['input']>;
  passwordHashLTE?: InputMaybe<Scalars['String']['input']>;
  passwordHashNEQ?: InputMaybe<Scalars['String']['input']>;
  passwordHashNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type CreateUserMutationVariables = Exact<{
  input: CreateUserInput;
}>;


export type CreateUserMutation = { __typename?: 'Mutation', createUser: { __typename?: 'User', id: string, nickname: string, email: string, introduction: string } };

export type UpdateUserMutationVariables = Exact<{
  input: UpdateUserInput;
}>;


export type UpdateUserMutation = { __typename?: 'Mutation', updateUser: { __typename?: 'User', id: string, nickname: string, email: string, introduction: string } };

export type CreateMatchMutationVariables = Exact<{
  input: CreateMatchInput;
}>;


export type CreateMatchMutation = { __typename?: 'Mutation', createMatch: { __typename?: 'Match', id: string, title: string, date: any, location: string, level: MatchLevel, participants: number, fee: number, notes: string, creatorID: string, isApplied: boolean } };

export type UpdateMatchMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateMatchInput;
}>;


export type UpdateMatchMutation = { __typename?: 'Mutation', updateMatch: { __typename?: 'Match', id: string, title: string, date: any, location: string, level: MatchLevel, participants: number, fee: number, notes: string, creatorID: string, isApplied: boolean } };

export type CreateParticipationMutationVariables = Exact<{
  input: CreateParticipationInput;
}>;


export type CreateParticipationMutation = { __typename?: 'Mutation', createParticipation: { __typename?: 'Participation', id: string, userID: string, matchID: string, status: ParticipationStatus } };

export type UpdateParticipationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  input: UpdateParticipationInput;
}>;


export type UpdateParticipationMutation = { __typename?: 'Mutation', updateParticipation: { __typename?: 'Participation', id: string, userID: string, matchID: string, status: ParticipationStatus } };

export type LoginMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'Mutation', login: string };

export type UserQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, nickname: string, email: string, introduction: string } };

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users: Array<{ __typename?: 'User', id: string, nickname: string, email: string, introduction: string }> };

export type MatchQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type MatchQuery = { __typename?: 'Query', matche: { __typename?: 'Match', id: string, title: string, date: any, location: string, level: MatchLevel, participants: number, fee: number, notes: string, creatorID: string, isApplied: boolean } };

export type MatchesQueryVariables = Exact<{ [key: string]: never; }>;


export type MatchesQuery = { __typename?: 'Query', matches: Array<{ __typename?: 'Match', id: string, title: string, date: any, location: string, level: MatchLevel, participants: number, fee: number, notes: string, creatorID: string, isApplied: boolean }> };

export type ParticipationQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ParticipationQuery = { __typename?: 'Query', participation: { __typename?: 'Participation', id: string, userID: string, matchID: string, status: ParticipationStatus } };

export type ParticipationsQueryVariables = Exact<{ [key: string]: never; }>;


export type ParticipationsQuery = { __typename?: 'Query', participations: Array<{ __typename?: 'Participation', id: string, userID: string, matchID: string, status: ParticipationStatus }> };

export type NodeQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type NodeQuery = { __typename?: 'Query', node?: { __typename?: 'Match', id: string } | { __typename?: 'Participation', id: string } | { __typename?: 'User', id: string } | null };

export type NodesQueryVariables = Exact<{
  ids: Array<Scalars['ID']['input']> | Scalars['ID']['input'];
}>;


export type NodesQuery = { __typename?: 'Query', nodes: Array<{ __typename?: 'Match', id: string } | { __typename?: 'Participation', id: string } | { __typename?: 'User', id: string } | null> };


// export const CreateUserDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateUser"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateUserInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createUser"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"introduction"}}]}}]}}]} as unknown as DocumentNode<CreateUserMutation, CreateUserMutationVariables>;
// export const UpdateUserDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateUser"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UpdateUserInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateUser"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"introduction"}}]}}]}}]} as unknown as DocumentNode<UpdateUserMutation, UpdateUserMutationVariables>;
// export const CreateMatchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateMatch"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateMatchInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createMatch"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"date"}},{"kind":"Field","name":{"kind":"Name","value":"location"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"participants"}},{"kind":"Field","name":{"kind":"Name","value":"fee"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}},{"kind":"Field","name":{"kind":"Name","value":"creatorID"}},{"kind":"Field","name":{"kind":"Name","value":"isApplied"}}]}}]}}]} as unknown as DocumentNode<CreateMatchMutation, CreateMatchMutationVariables>;
// export const UpdateMatchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateMatch"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UpdateMatchInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateMatch"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}},{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"date"}},{"kind":"Field","name":{"kind":"Name","value":"location"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"participants"}},{"kind":"Field","name":{"kind":"Name","value":"fee"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}},{"kind":"Field","name":{"kind":"Name","value":"creatorID"}},{"kind":"Field","name":{"kind":"Name","value":"isApplied"}}]}}]}}]} as unknown as DocumentNode<UpdateMatchMutation, UpdateMatchMutationVariables>;
// export const CreateParticipationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateParticipation"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateParticipationInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createParticipation"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"matchID"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]}}]} as unknown as DocumentNode<CreateParticipationMutation, CreateParticipationMutationVariables>;
// export const UpdateParticipationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateParticipation"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UpdateParticipationInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateParticipation"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}},{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"matchID"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]}}]} as unknown as DocumentNode<UpdateParticipationMutation, UpdateParticipationMutationVariables>;
// export const LoginDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"Login"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"email"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"password"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"login"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"email"},"value":{"kind":"Variable","name":{"kind":"Name","value":"email"}}},{"kind":"Argument","name":{"kind":"Name","value":"password"},"value":{"kind":"Variable","name":{"kind":"Name","value":"password"}}}]}]}}]} as unknown as DocumentNode<LoginMutation, LoginMutationVariables>;
// export const UserDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"User"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"user"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"introduction"}}]}}]}}]} as unknown as DocumentNode<UserQuery, UserQueryVariables>;
// export const UsersDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Users"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"users"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"introduction"}}]}}]}}]} as unknown as DocumentNode<UsersQuery, UsersQueryVariables>;
// export const MatchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Match"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"matche"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"date"}},{"kind":"Field","name":{"kind":"Name","value":"location"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"participants"}},{"kind":"Field","name":{"kind":"Name","value":"fee"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}},{"kind":"Field","name":{"kind":"Name","value":"creatorID"}},{"kind":"Field","name":{"kind":"Name","value":"isApplied"}}]}}]}}]} as unknown as DocumentNode<MatchQuery, MatchQueryVariables>;
// export const MatchesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Matches"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"matches"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"date"}},{"kind":"Field","name":{"kind":"Name","value":"location"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"participants"}},{"kind":"Field","name":{"kind":"Name","value":"fee"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}},{"kind":"Field","name":{"kind":"Name","value":"creatorID"}},{"kind":"Field","name":{"kind":"Name","value":"isApplied"}}]}}]}}]} as unknown as DocumentNode<MatchesQuery, MatchesQueryVariables>;
// export const ParticipationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Participation"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"participation"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"matchID"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]}}]} as unknown as DocumentNode<ParticipationQuery, ParticipationQueryVariables>;
// export const ParticipationsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Participations"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"participations"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"matchID"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]}}]} as unknown as DocumentNode<ParticipationsQuery, ParticipationsQueryVariables>;
// export const NodeDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Node"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]} as unknown as DocumentNode<NodeQuery, NodeQueryVariables>;
// export const NodesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Nodes"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"ids"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nodes"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"ids"},"value":{"kind":"Variable","name":{"kind":"Name","value":"ids"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}}]}}]} as unknown as DocumentNode<NodesQuery, NodesQueryVariables>;


export const CreateUserDocument = gql`
    mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    nickname
    email
    introduction
  }
}
    `;
export type CreateUserMutationFn = Apollo.MutationFunction<CreateUserMutation, CreateUserMutationVariables>;

/**
 * __useCreateUserMutation__
 *
 * To run a mutation, you first call `useCreateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserMutation, { data, loading, error }] = useCreateUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserMutation, CreateUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, options);
      }
export type CreateUserMutationHookResult = ReturnType<typeof useCreateUserMutation>;
export type CreateUserMutationResult = Apollo.MutationResult<CreateUserMutation>;
export type CreateUserMutationOptions = Apollo.BaseMutationOptions<CreateUserMutation, CreateUserMutationVariables>;
export const UpdateUserDocument = gql`
    mutation UpdateUser($input: UpdateUserInput!) {
  updateUser(input: $input) {
    id
    nickname
    email
    introduction
  }
}
    `;
export type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, options);
      }
export type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;
export type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;
export const CreateMatchDocument = gql`
    mutation CreateMatch($input: CreateMatchInput!) {
  createMatch(input: $input) {
    id
    title
    date
    location
    level
    participants
    fee
    notes
    creatorID
    isApplied
  }
}
    `;
export type CreateMatchMutationFn = Apollo.MutationFunction<CreateMatchMutation, CreateMatchMutationVariables>;

/**
 * __useCreateMatchMutation__
 *
 * To run a mutation, you first call `useCreateMatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMatchMutation, { data, loading, error }] = useCreateMatchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateMatchMutation(baseOptions?: Apollo.MutationHookOptions<CreateMatchMutation, CreateMatchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateMatchMutation, CreateMatchMutationVariables>(CreateMatchDocument, options);
      }
export type CreateMatchMutationHookResult = ReturnType<typeof useCreateMatchMutation>;
export type CreateMatchMutationResult = Apollo.MutationResult<CreateMatchMutation>;
export type CreateMatchMutationOptions = Apollo.BaseMutationOptions<CreateMatchMutation, CreateMatchMutationVariables>;
export const UpdateMatchDocument = gql`
    mutation UpdateMatch($id: ID!, $input: UpdateMatchInput!) {
  updateMatch(id: $id, input: $input) {
    id
    title
    date
    location
    level
    participants
    fee
    notes
    creatorID
    isApplied
  }
}
    `;
export type UpdateMatchMutationFn = Apollo.MutationFunction<UpdateMatchMutation, UpdateMatchMutationVariables>;

/**
 * __useUpdateMatchMutation__
 *
 * To run a mutation, you first call `useUpdateMatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMatchMutation, { data, loading, error }] = useUpdateMatchMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMatchMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMatchMutation, UpdateMatchMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMatchMutation, UpdateMatchMutationVariables>(UpdateMatchDocument, options);
      }
export type UpdateMatchMutationHookResult = ReturnType<typeof useUpdateMatchMutation>;
export type UpdateMatchMutationResult = Apollo.MutationResult<UpdateMatchMutation>;
export type UpdateMatchMutationOptions = Apollo.BaseMutationOptions<UpdateMatchMutation, UpdateMatchMutationVariables>;
export const CreateParticipationDocument = gql`
    mutation CreateParticipation($input: CreateParticipationInput!) {
  createParticipation(input: $input) {
    id
    userID
    matchID
    status
  }
}
    `;
export type CreateParticipationMutationFn = Apollo.MutationFunction<CreateParticipationMutation, CreateParticipationMutationVariables>;

/**
 * __useCreateParticipationMutation__
 *
 * To run a mutation, you first call `useCreateParticipationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateParticipationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createParticipationMutation, { data, loading, error }] = useCreateParticipationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateParticipationMutation(baseOptions?: Apollo.MutationHookOptions<CreateParticipationMutation, CreateParticipationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateParticipationMutation, CreateParticipationMutationVariables>(CreateParticipationDocument, options);
      }
export type CreateParticipationMutationHookResult = ReturnType<typeof useCreateParticipationMutation>;
export type CreateParticipationMutationResult = Apollo.MutationResult<CreateParticipationMutation>;
export type CreateParticipationMutationOptions = Apollo.BaseMutationOptions<CreateParticipationMutation, CreateParticipationMutationVariables>;
export const UpdateParticipationDocument = gql`
    mutation UpdateParticipation($id: ID!, $input: UpdateParticipationInput!) {
  updateParticipation(id: $id, input: $input) {
    id
    userID
    matchID
    status
  }
}
    `;
export type UpdateParticipationMutationFn = Apollo.MutationFunction<UpdateParticipationMutation, UpdateParticipationMutationVariables>;

/**
 * __useUpdateParticipationMutation__
 *
 * To run a mutation, you first call `useUpdateParticipationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateParticipationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateParticipationMutation, { data, loading, error }] = useUpdateParticipationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateParticipationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateParticipationMutation, UpdateParticipationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateParticipationMutation, UpdateParticipationMutationVariables>(UpdateParticipationDocument, options);
      }
export type UpdateParticipationMutationHookResult = ReturnType<typeof useUpdateParticipationMutation>;
export type UpdateParticipationMutationResult = Apollo.MutationResult<UpdateParticipationMutation>;
export type UpdateParticipationMutationOptions = Apollo.BaseMutationOptions<UpdateParticipationMutation, UpdateParticipationMutationVariables>;
export const LoginDocument = gql`
    mutation Login($email: String!, $password: String!) {
  login(email: $email, password: $password)
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const UserDocument = gql`
    query User($id: ID!) {
  user(id: $id) {
    id
    nickname
    email
    introduction
  }
}
    `;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserQuery(baseOptions: Apollo.QueryHookOptions<UserQuery, UserQueryVariables> & ({ variables: UserQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, options);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export function useUserSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserSuspenseQueryHookResult = ReturnType<typeof useUserSuspenseQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const UsersDocument = gql`
    query Users {
  users {
    id
    nickname
    email
    introduction
  }
}
    `;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const MatchDocument = gql`
    query Match($id: ID!) {
  matche(id: $id) {
    id
    title
    date
    location
    level
    participants
    fee
    notes
    creatorID
    isApplied
  }
}
    `;

/**
 * __useMatchQuery__
 *
 * To run a query within a React component, call `useMatchQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMatchQuery(baseOptions: Apollo.QueryHookOptions<MatchQuery, MatchQueryVariables> & ({ variables: MatchQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchQuery, MatchQueryVariables>(MatchDocument, options);
      }
export function useMatchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchQuery, MatchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchQuery, MatchQueryVariables>(MatchDocument, options);
        }
export function useMatchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MatchQuery, MatchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MatchQuery, MatchQueryVariables>(MatchDocument, options);
        }
export type MatchQueryHookResult = ReturnType<typeof useMatchQuery>;
export type MatchLazyQueryHookResult = ReturnType<typeof useMatchLazyQuery>;
export type MatchSuspenseQueryHookResult = ReturnType<typeof useMatchSuspenseQuery>;
export type MatchQueryResult = Apollo.QueryResult<MatchQuery, MatchQueryVariables>;
export const MatchesDocument = gql`
    query Matches {
  matches {
    id
    title
    date
    location
    level
    participants
    fee
    notes
    creatorID
    isApplied
  }
}
    `;

/**
 * __useMatchesQuery__
 *
 * To run a query within a React component, call `useMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchesQuery({
 *   variables: {
 *   },
 * });
 */
export function useMatchesQuery(baseOptions?: Apollo.QueryHookOptions<MatchesQuery, MatchesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MatchesQuery, MatchesQueryVariables>(MatchesDocument, options);
      }
export function useMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MatchesQuery, MatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MatchesQuery, MatchesQueryVariables>(MatchesDocument, options);
        }
export function useMatchesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MatchesQuery, MatchesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MatchesQuery, MatchesQueryVariables>(MatchesDocument, options);
        }
export type MatchesQueryHookResult = ReturnType<typeof useMatchesQuery>;
export type MatchesLazyQueryHookResult = ReturnType<typeof useMatchesLazyQuery>;
export type MatchesSuspenseQueryHookResult = ReturnType<typeof useMatchesSuspenseQuery>;
export type MatchesQueryResult = Apollo.QueryResult<MatchesQuery, MatchesQueryVariables>;
export const ParticipationDocument = gql`
    query Participation($id: ID!) {
  participation(id: $id) {
    id
    userID
    matchID
    status
  }
}
    `;

/**
 * __useParticipationQuery__
 *
 * To run a query within a React component, call `useParticipationQuery` and pass it any options that fit your needs.
 * When your component renders, `useParticipationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useParticipationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useParticipationQuery(baseOptions: Apollo.QueryHookOptions<ParticipationQuery, ParticipationQueryVariables> & ({ variables: ParticipationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ParticipationQuery, ParticipationQueryVariables>(ParticipationDocument, options);
      }
export function useParticipationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ParticipationQuery, ParticipationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ParticipationQuery, ParticipationQueryVariables>(ParticipationDocument, options);
        }
export function useParticipationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ParticipationQuery, ParticipationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ParticipationQuery, ParticipationQueryVariables>(ParticipationDocument, options);
        }
export type ParticipationQueryHookResult = ReturnType<typeof useParticipationQuery>;
export type ParticipationLazyQueryHookResult = ReturnType<typeof useParticipationLazyQuery>;
export type ParticipationSuspenseQueryHookResult = ReturnType<typeof useParticipationSuspenseQuery>;
export type ParticipationQueryResult = Apollo.QueryResult<ParticipationQuery, ParticipationQueryVariables>;
export const ParticipationsDocument = gql`
    query Participations {
  participations {
    id
    userID
    matchID
    status
  }
}
    `;

/**
 * __useParticipationsQuery__
 *
 * To run a query within a React component, call `useParticipationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useParticipationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useParticipationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useParticipationsQuery(baseOptions?: Apollo.QueryHookOptions<ParticipationsQuery, ParticipationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ParticipationsQuery, ParticipationsQueryVariables>(ParticipationsDocument, options);
      }
export function useParticipationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ParticipationsQuery, ParticipationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ParticipationsQuery, ParticipationsQueryVariables>(ParticipationsDocument, options);
        }
export function useParticipationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ParticipationsQuery, ParticipationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ParticipationsQuery, ParticipationsQueryVariables>(ParticipationsDocument, options);
        }
export type ParticipationsQueryHookResult = ReturnType<typeof useParticipationsQuery>;
export type ParticipationsLazyQueryHookResult = ReturnType<typeof useParticipationsLazyQuery>;
export type ParticipationsSuspenseQueryHookResult = ReturnType<typeof useParticipationsSuspenseQuery>;
export type ParticipationsQueryResult = Apollo.QueryResult<ParticipationsQuery, ParticipationsQueryVariables>;
export const NodeDocument = gql`
    query Node($id: ID!) {
  node(id: $id) {
    id
  }
}
    `;

/**
 * __useNodeQuery__
 *
 * To run a query within a React component, call `useNodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useNodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNodeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useNodeQuery(baseOptions: Apollo.QueryHookOptions<NodeQuery, NodeQueryVariables> & ({ variables: NodeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
      }
export function useNodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NodeQuery, NodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
        }
export function useNodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<NodeQuery, NodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
        }
export type NodeQueryHookResult = ReturnType<typeof useNodeQuery>;
export type NodeLazyQueryHookResult = ReturnType<typeof useNodeLazyQuery>;
export type NodeSuspenseQueryHookResult = ReturnType<typeof useNodeSuspenseQuery>;
export type NodeQueryResult = Apollo.QueryResult<NodeQuery, NodeQueryVariables>;
export const NodesDocument = gql`
    query Nodes($ids: [ID!]!) {
  nodes(ids: $ids) {
    id
  }
}
    `;

/**
 * __useNodesQuery__
 *
 * To run a query within a React component, call `useNodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useNodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNodesQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useNodesQuery(baseOptions: Apollo.QueryHookOptions<NodesQuery, NodesQueryVariables> & ({ variables: NodesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NodesQuery, NodesQueryVariables>(NodesDocument, options);
      }
export function useNodesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NodesQuery, NodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NodesQuery, NodesQueryVariables>(NodesDocument, options);
        }
export function useNodesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<NodesQuery, NodesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NodesQuery, NodesQueryVariables>(NodesDocument, options);
        }
export type NodesQueryHookResult = ReturnType<typeof useNodesQuery>;
export type NodesLazyQueryHookResult = ReturnType<typeof useNodesLazyQuery>;
export type NodesSuspenseQueryHookResult = ReturnType<typeof useNodesSuspenseQuery>;
export type NodesQueryResult = Apollo.QueryResult<NodesQuery, NodesQueryVariables>;