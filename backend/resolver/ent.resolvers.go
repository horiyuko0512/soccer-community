package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/horiyuko0512/soccer-community/ent"
	"github.com/horiyuko0512/soccer-community/ent/match"
	"github.com/horiyuko0512/soccer-community/ent/participation"
	"github.com/horiyuko0512/soccer-community/ent/user"
	"github.com/horiyuko0512/soccer-community/internal/auth"
	"github.com/horiyuko0512/soccer-community/internal/middleware"
	"github.com/horiyuko0512/soccer-community/resolver/model"
)

// CreateMatch is the resolver for the CreateMatch field.
func (r *mutationResolver) CreateMatch(ctx context.Context, input model.CreateMatchInput) (*model.Match, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	match, err := r.client.Match.
		Create().
		SetTitle(input.Title).
		SetStartAt(input.StartAt).
		SetEndAt(input.EndAt).
		SetLocation(input.Location).
		SetLevel(input.Level).
		SetParticipants(int(input.Participants)).
		SetFee(int(input.Fee)).
		SetNotes(input.Notes).
		SetCreatorID(uuid.MustParse(userId)).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create match: %w", err)
	}
	return &model.Match{
		ID:           match.ID.String(),
		Title:        match.Title,
		StartAt:      match.StartAt,
		EndAt:        match.EndAt,
		Location:     match.Location,
		Level:        match.Level,
		Participants: int32(match.Participants),
		Fee:          int32(match.Fee),
		Notes:        match.Notes,
		CreatorID:    match.CreatorID.String(),
		IsApplied:    match.IsApplied,
	}, nil
}

// UpdateMatch is the resolver for the UpdateMatch field.
func (r *mutationResolver) UpdateMatch(ctx context.Context, id string, input model.UpdateMatchInput) (*model.Match, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	update_match, err := r.client.Match.Get(ctx, uuid.MustParse(id))
	if err != nil {
		return nil, fmt.Errorf("failed getting match: %w", err)
	}
	if update_match.CreatorID.String() != userId {
		return nil, fmt.Errorf("forbidden: only the creator can update the match")
	}
	update := r.client.Match.UpdateOneID(uuid.MustParse(id))
	if input.Title != nil {
		update = update.SetTitle(*input.Title)
	}
	if input.StartAt != nil {
		update = update.SetStartAt(*input.StartAt)
	}
	if input.EndAt != nil {
		update = update.SetEndAt(*input.EndAt)
	}
	if input.Location != nil {
		update = update.SetLocation(*input.Location)
	}
	if input.Level != nil {
		update = update.SetLevel(*input.Level)
	}
	if input.Participants != nil {
		update = update.SetParticipants(int(*input.Participants))
	}
	if input.Fee != nil {
		update = update.SetFee(int(*input.Fee))
	}
	if input.Notes != nil {
		update = update.SetNotes(*input.Notes)
	}
	update.SetUpdatedAt(time.Now())
	if input.IsApplied != nil {
		update = update.SetIsApplied(*input.IsApplied)
	}
	match, err := update.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed updating match: %w", err)
	}
	return &model.Match{
		ID:           match.ID.String(),
		Title:        match.Title,
		StartAt:      match.StartAt,
		EndAt:        match.EndAt,
		Location:     match.Location,
		Level:        match.Level,
		Participants: int32(match.Participants),
		Fee:          int32(match.Fee),
		Notes:        match.Notes,
		CreatorID:    match.CreatorID.String(),
		IsApplied:    match.IsApplied,
	}, nil
}

// CreateParticipation is the resolver for the CreateParticipation field.
func (r *mutationResolver) CreateParticipation(ctx context.Context, input model.CreateParticipationInput) (*model.Participation, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	participation, err := r.client.Participation.
		Create().
		SetUserID(uuid.MustParse(userId)).
		SetMatchID(uuid.MustParse(input.MatchID)).
		SetStatus(*input.Status).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create participation: %w", err)
	}
	return &model.Participation{
		ID:      participation.ID.String(),
		UserID:  participation.UserID.String(),
		MatchID: participation.MatchID.String(),
		Status:  participation.Status,
	}, nil
}

// UpdateParticipation is the resolver for the UpdateParticipation field.
func (r *mutationResolver) UpdateParticipation(ctx context.Context, id string, input model.UpdateParticipationInput) (*model.Participation, error) {
	_, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	participationID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid participation ID: %w", err)
	}
	update := r.client.Participation.UpdateOneID(participationID)
	if input.Status != nil {
		update = update.SetStatus(*input.Status)
	}
	update.SetUpdatedAt(time.Now())
	participation, err := update.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed updating participation: %w", err)
	}
	return &model.Participation{
		ID:      participation.ID.String(),
		UserID:  participation.UserID.String(),
		MatchID: participation.MatchID.String(),
		Status:  participation.Status,
	}, nil
}

// CreateUser is the resolver for the CreateUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (string, error) {
	hashedPassword, err := auth.PasswordEncrypt(input.PasswordHash)
	if err != nil {
		return "パスワードの暗号化に失敗しました", fmt.Errorf("failed to encrypt password: %w", err)
	}

	user, err := r.client.User.
		Create().
		SetNickName(input.Nickname).
		SetEmail(input.Email).
		SetPasswordHash(hashedPassword).
		SetIntroduction(input.Introduction).
		Save(ctx)
	if err != nil {
		return "ユーザー作成に失敗しました", fmt.Errorf("failed to create user: %w", err)
	}

	//JWTの生成
	token, err := auth.GenerateJWT(user.ID.String())
	if err != nil {
		return "トークンの生成に失敗しました", fmt.Errorf("failed to generate token: %w", err)
	}

	//リフレッシュトークンの生成
	refresh_token, err := auth.GenerateRefreshToken()
	if err != nil {
		return "リフレッシュトークンの生成に失敗しました", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	//リフレッシュトークンの保存
	_, err = r.client.User.UpdateOneID(user.ID).
		SetRefreshToken(refresh_token).
		Save(ctx)
	if err != nil {
		return "リフレッシュトークンの保存に失敗しました", fmt.Errorf("failed to save refresh token: %w", err)
	}

	//Cookieの設定
	auth.SetCookie(ctx, refresh_token)

	return token, nil
}

// UpdateUser is the resolver for the UpdateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	update := r.client.User.UpdateOneID(uuid.MustParse(userId))
	if input.Nickname != nil {
		update = update.SetNickName(*input.Nickname)
	}
	if input.Email != nil {
		update = update.SetEmail(*input.Email)
	}
	if input.PasswordHash != nil {
		update = update.SetPasswordHash(*input.PasswordHash)
	}
	if input.Introduction != nil {
		update = update.SetIntroduction(*input.Introduction)
	}
	update.SetUpdatedAt(time.Now())
	user, err := update.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed updating user: %w", err)
	}
	return &model.User{
		ID:           user.ID.String(),
		NickName:     user.NickName,
		Email:        user.Email,
		Introduction: user.Introduction,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	user, err := r.client.User.Query().Where(user.EmailEQ(email)).Only(ctx)
	if err != nil {
		return "ユーザー情報の取得に失敗しました", fmt.Errorf("failed to get user: %w", err)
	}

	err = auth.CompareHashAndPassword(user.PasswordHash, password)
	if err != nil {
		return "ユーザーネームかパスワードが違います", fmt.Errorf("failed to compare password: %w", err)
	}

	//JWTの生成
	token, err := auth.GenerateJWT(user.ID.String())
	if err != nil {
		return "トークンの生成に失敗しました", fmt.Errorf("failed to generate token: %w", err)
	}

	//リフレッシュトークンの生成
	refresh_token, err := auth.GenerateRefreshToken()
	if err != nil {
		return "リフレッシュトークンの生成に失敗しました", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	//リフレッシュトークンの保存
	_, err = r.client.User.UpdateOneID(user.ID).
		SetRefreshToken(refresh_token).
		Save(ctx)
	if err != nil {
		return "リフレッシュトークンの保存に失敗しました", fmt.Errorf("failed to save refresh token: %w", err)
	}

	//Cookieの設定
	auth.SetCookie(ctx, refresh_token)

	return token, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return false, fmt.Errorf("Unauthorized")
	}
	_, err := r.client.User.UpdateOneID(uuid.MustParse(userId)).
		SetRefreshToken("").
		Save(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to update refresh token: %w", err)
	}
	return true, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (ent.Noder, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, ids []string) ([]ent.Noder, error) {
	panic(fmt.Errorf("not implemented: Nodes - nodes"))
}

// Matche is the resolver for the matche field.
func (r *queryResolver) Match(ctx context.Context, id string) (*model.Match, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	match, err := r.client.Match.Get(ctx, uuid.MustParse(id))
	if err != nil {
		return nil, fmt.Errorf("failed getting match: %w", err)
	}
	isCreator := "true"
	if userId != match.CreatorID.String() {
		isCreator = "false"
	}
	return &model.Match{
		ID:           match.ID.String(),
		Title:        match.Title,
		StartAt:      match.StartAt,
		EndAt:        match.EndAt,
		Location:     match.Location,
		Level:        match.Level,
		Participants: int32(match.Participants),
		Fee:          int32(match.Fee),
		Notes:        match.Notes,
		CreatorID:    isCreator,
		IsApplied:    match.IsApplied,
	}, nil
}

// Matches is the resolver for the matches field.
func (r *queryResolver) Matches(ctx context.Context) ([]*model.Match, error) {
	_, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	matches, err := r.client.Match.Query().
		WithCreator().
		Order(ent.Desc(match.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed querying matches: %w", err)
	}

	var result []*model.Match
	for _, match := range matches {
		result = append(result, &model.Match{
			ID:           match.ID.String(),
			Title:        match.Title,
			StartAt:      match.StartAt,
			EndAt:        match.EndAt,
			Location:     match.Location,
			Level:        match.Level,
			Participants: int32(match.Participants),
			Fee:          int32(match.Fee),
			Notes:        match.Notes,
			CreatorID:    match.CreatorID.String(),
			IsApplied:    match.IsApplied,
		})
	}
	return result, nil
}

// MatchesByCreatorID is the resolver for the matchesByCreatorId field.
func (r *queryResolver) MatchesByCreatorID(ctx context.Context) ([]*model.Match, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	matches, err := r.client.Match.Query().
		Where(match.HasCreatorWith(user.ID(uuid.MustParse(userId)))).
		Order(ent.Desc(match.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed querying matches: %w", err)
	}

	var result []*model.Match
	for _, match := range matches {
		result = append(result, &model.Match{
			ID:       match.ID.String(),
			Title:    match.Title,
			StartAt:  match.StartAt,
			EndAt:    match.EndAt,
			Location: match.Location,
		})
	}
	return result, nil
}

// SearchMatches is the resolver for the searchMatches field.
func (r *queryResolver) SearchMatches(ctx context.Context, input model.SearchMatchInput) ([]*model.Match, error) {
	_, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	query := r.client.Match.Query()
  if input.Date != nil {
    jst, err := time.LoadLocation("Asia/Tokyo")
    if err != nil {
      return nil, fmt.Errorf("failed to load JST location: %w", err)
    }
    jstTime := input.Date.In(jst)
		startJST := time.Date(jstTime.Year(), jstTime.Month(), jstTime.Day(), 0, 0, 0, 0, jst)
    endJST := startJST.Add(24 * time.Hour - time.Second)
    startUTC := startJST.UTC()
    endUTC := endJST.UTC()
    query = query.Where(
		  match.And(
        match.StartAtGTE(startUTC),
        match.StartAtLTE(endUTC),
      ),
    )
  }
	if input.StartTime != nil && input.EndTime != nil {
    startTimeMinutes := input.StartTime.UTC().Hour()*60 + input.StartTime.UTC().Minute()
    endTimeMinutes := input.EndTime.UTC().Hour()*60 + input.EndTime.UTC().Minute()
    query = query.Where(func(s *sql.Selector) {
			expr := fmt.Sprintf(
				"(EXTRACT(HOUR FROM %s::timestamp) * 60 + EXTRACT(MINUTE FROM %s::timestamp)) >= $3 AND " +
				"(EXTRACT(HOUR FROM %s::timestamp) * 60 + EXTRACT(MINUTE FROM %s::timestamp)) <= $4",
				match.FieldStartAt, match.FieldStartAt,
				match.FieldEndAt, match.FieldEndAt,
			)
			s.Where(sql.ExprP(expr, startTimeMinutes, endTimeMinutes))
    })
	}
	if input.Location != nil && *input.Location != "" {
		query = query.Where(
			match.LocationContains(*input.Location),
		)
	}
	if input.Level != nil {
		query = query.Where(
			match.LevelEQ(*input.Level),
		)
	}
	if input.ParticipantsMin != nil && *input.ParticipantsMin > 0 {
		query = query.Where(
			match.ParticipantsGTE(int(*input.ParticipantsMin)),
		)
	}
	if input.ParticipantsMax != nil && *input.ParticipantsMax > 0 {
		query = query.Where(
			match.ParticipantsLTE(int(*input.ParticipantsMax)),
		)
	}
	if input.FeeMin != nil && *input.FeeMin >= 0 {
		query = query.Where(
			match.FeeGTE(int(*input.FeeMin)),
		)
	}
	if input.FeeMax != nil && *input.FeeMax >= 0 {
		query = query.Where(
			match.FeeLTE(int(*input.FeeMax)),
		)
	}
	if input.IsApplied != nil && *input.IsApplied {
		query = query.Where(
			match.IsApplied(*input.IsApplied),
		)
	}
	matches, err := query.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to search matches: %w", err)
	}
	result := make([]*model.Match, len(matches))
	for i, match := range matches {
		result[i] = &model.Match{
			ID:           match.ID.String(),
			Title:        match.Title,
			StartAt:      match.StartAt,
			EndAt:        match.EndAt,
			Location:     match.Location,
			Level:        match.Level,
			Participants: int32(match.Participants),
			Fee:          int32(match.Fee),
			Notes:        match.Notes,
			CreatorID:    match.CreatorID.String(),
			IsApplied:    match.IsApplied,
		}
	}
	return result, nil
}

// ParticipationByUserIDAndMatchID is the resolver for the participationByUserIdAndMatchId field.
func (r *queryResolver) ParticipationByUserIDAndMatchID(ctx context.Context, matchID string) (bool, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return false, fmt.Errorf("Unauthorized")
	}
	exists, err := r.client.Participation.Query().
		Where(participation.And(
			participation.HasUserWith(user.ID(uuid.MustParse(userId))),
			participation.HasMatchWith(match.ID(uuid.MustParse(matchID))),
		)).
		Exist(ctx)
	if err != nil {
		return false, fmt.Errorf("failed querying participation: %w", err)
	}
	return exists, nil
}

// ParticipationsByUserID is the resolver for the participationsByUserId field.
func (r *queryResolver) ParticipationsByUserID(ctx context.Context) ([]*model.Participation, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	participations, err := r.client.Participation.Query().
		Where(participation.HasUserWith(user.ID(uuid.MustParse(userId)))).
		WithMatch().
		Order(ent.Desc(participation.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed querying participations: %w", err)
	}

	var result []*model.Participation
	for _, participation := range participations {
		result = append(result, &model.Participation{
			ID:      participation.ID.String(),
			UserID:  participation.UserID.String(),
			MatchID: participation.MatchID.String(),
			Status:  participation.Status,
			Match: &model.Match{
				ID:       participation.Edges.Match.ID.String(),
				Title:    participation.Edges.Match.Title,
				StartAt:  participation.Edges.Match.StartAt,
				EndAt:    participation.Edges.Match.EndAt,
				Location: participation.Edges.Match.Location,
			},
		})
	}
	return result, nil
}

// ParticipationsByMatchID is the resolver for the participationsByMatchId field.
func (r *queryResolver) ParticipationsByMatchID(ctx context.Context, matchID string) ([]*model.Participation, error) {
	_, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	participations, err := r.client.Participation.Query().
		Where(participation.HasMatchWith(match.ID(uuid.MustParse(matchID)))).
		WithUser().
		Order(ent.Desc(participation.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed querying participations: %w", err)
	}

	var result []*model.Participation
	for _, participation := range participations {
		result = append(result, &model.Participation{
			ID:     participation.ID.String(),
			UserID: participation.UserID.String(),
			Status: participation.Status,
			User: &model.User{
				ID:           participation.Edges.User.ID.String(),
				NickName:     participation.Edges.User.NickName,
				Introduction: participation.Edges.User.Introduction,
			},
		})
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*model.User, error) {
	userId, ok := ctx.Value(middleware.UserIdKey).(string)
	if !ok {
		return nil, fmt.Errorf("Unauthorized")
	}
	user, err := r.client.User.Get(ctx, uuid.MustParse(userId))
	if err != nil {
		return nil, fmt.Errorf("failed getting user: %w", err)
	}
	return &model.User{
		NickName:     user.NickName,
		Introduction: user.Introduction,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
