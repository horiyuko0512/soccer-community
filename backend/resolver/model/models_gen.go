// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/horiyuko0512/soccer-community/ent/match"
	"github.com/horiyuko0512/soccer-community/ent/participation"
)

// CreateMatchInput is used for create Match object.
// Input was generated by ent.
type CreateMatchInput struct {
	Title                 string      `json:"title"`
	Date                  time.Time   `json:"date"`
	Location              string      `json:"location"`
	Level                 match.Level `json:"level"`
	Participants          int32       `json:"participants"`
	Fee                   int32       `json:"fee"`
	Notes                 string      `json:"notes"`
	CreatedAt             *time.Time  `json:"createdAt,omitempty"`
	UpdatedAt             *time.Time  `json:"updatedAt,omitempty"`
	IsApplied             *bool       `json:"isApplied,omitempty"`
	CreatorID             string      `json:"creatorID"`
	MatchParticipationIDs []string    `json:"matchParticipationIDs,omitempty"`
}

// CreateParticipationInput is used for create Participation object.
// Input was generated by ent.
type CreateParticipationInput struct {
	Status    *participation.Status `json:"status,omitempty"`
	CreatedAt *time.Time            `json:"createdAt,omitempty"`
	UpdatedAt *time.Time            `json:"updatedAt,omitempty"`
	UserID    string                `json:"userID"`
	MatchID   string                `json:"matchID"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	Nickname             string     `json:"nickname"`
	Email                string     `json:"email"`
	PasswordHash         string     `json:"passwordHash"`
	Introduction         string     `json:"introduction"`
	CreatedAt            *time.Time `json:"createdAt,omitempty"`
	UpdatedAt            *time.Time `json:"updatedAt,omitempty"`
	MatchIDs             []string   `json:"matchIDs,omitempty"`
	UserParticipationIDs []string   `json:"userParticipationIDs,omitempty"`
}

type Match struct {
	ID                 string           `json:"id"`
	Title              string           `json:"title"`
	Date               time.Time        `json:"date"`
	Location           string           `json:"location"`
	Level              match.Level      `json:"level"`
	Participants       int32            `json:"participants"`
	Fee                int32            `json:"fee"`
	Notes              string           `json:"notes"`
	CreatorID          string           `json:"creatorID"`
	CreatedAt          time.Time        `json:"createdAt"`
	UpdatedAt          time.Time        `json:"updatedAt"`
	IsApplied          bool             `json:"isApplied"`
	Creator            *User            `json:"creator"`
	MatchParticipation []*Participation `json:"matchParticipation,omitempty"`
}

func (Match) IsNode() {}

// MatchWhereInput is used for filtering Match objects.
// Input was generated by ent.
type MatchWhereInput struct {
	Not *MatchWhereInput   `json:"not,omitempty"`
	And []*MatchWhereInput `json:"and,omitempty"`
	Or  []*MatchWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// date field predicates
	Date      *time.Time   `json:"date,omitempty"`
	DateNeq   *time.Time   `json:"dateNEQ,omitempty"`
	DateIn    []*time.Time `json:"dateIn,omitempty"`
	DateNotIn []*time.Time `json:"dateNotIn,omitempty"`
	DateGt    *time.Time   `json:"dateGT,omitempty"`
	DateGte   *time.Time   `json:"dateGTE,omitempty"`
	DateLt    *time.Time   `json:"dateLT,omitempty"`
	DateLte   *time.Time   `json:"dateLTE,omitempty"`
	// location field predicates
	Location             *string  `json:"location,omitempty"`
	LocationNeq          *string  `json:"locationNEQ,omitempty"`
	LocationIn           []string `json:"locationIn,omitempty"`
	LocationNotIn        []string `json:"locationNotIn,omitempty"`
	LocationGt           *string  `json:"locationGT,omitempty"`
	LocationGte          *string  `json:"locationGTE,omitempty"`
	LocationLt           *string  `json:"locationLT,omitempty"`
	LocationLte          *string  `json:"locationLTE,omitempty"`
	LocationContains     *string  `json:"locationContains,omitempty"`
	LocationHasPrefix    *string  `json:"locationHasPrefix,omitempty"`
	LocationHasSuffix    *string  `json:"locationHasSuffix,omitempty"`
	LocationEqualFold    *string  `json:"locationEqualFold,omitempty"`
	LocationContainsFold *string  `json:"locationContainsFold,omitempty"`
	// level field predicates
	Level      *match.Level  `json:"level,omitempty"`
	LevelNeq   *match.Level  `json:"levelNEQ,omitempty"`
	LevelIn    []match.Level `json:"levelIn,omitempty"`
	LevelNotIn []match.Level `json:"levelNotIn,omitempty"`
	// participants field predicates
	Participants      *int32  `json:"participants,omitempty"`
	ParticipantsNeq   *int32  `json:"participantsNEQ,omitempty"`
	ParticipantsIn    []int32 `json:"participantsIn,omitempty"`
	ParticipantsNotIn []int32 `json:"participantsNotIn,omitempty"`
	ParticipantsGt    *int32  `json:"participantsGT,omitempty"`
	ParticipantsGte   *int32  `json:"participantsGTE,omitempty"`
	ParticipantsLt    *int32  `json:"participantsLT,omitempty"`
	ParticipantsLte   *int32  `json:"participantsLTE,omitempty"`
	// fee field predicates
	Fee      *int32  `json:"fee,omitempty"`
	FeeNeq   *int32  `json:"feeNEQ,omitempty"`
	FeeIn    []int32 `json:"feeIn,omitempty"`
	FeeNotIn []int32 `json:"feeNotIn,omitempty"`
	FeeGt    *int32  `json:"feeGT,omitempty"`
	FeeGte   *int32  `json:"feeGTE,omitempty"`
	FeeLt    *int32  `json:"feeLT,omitempty"`
	FeeLte   *int32  `json:"feeLTE,omitempty"`
	// notes field predicates
	Notes             *string  `json:"notes,omitempty"`
	NotesNeq          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGt           *string  `json:"notesGT,omitempty"`
	NotesGte          *string  `json:"notesGTE,omitempty"`
	NotesLt           *string  `json:"notesLT,omitempty"`
	NotesLte          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`
	// creator_id field predicates
	CreatorID      *string  `json:"creatorID,omitempty"`
	CreatorIdneq   *string  `json:"creatorIDNEQ,omitempty"`
	CreatorIDIn    []string `json:"creatorIDIn,omitempty"`
	CreatorIDNotIn []string `json:"creatorIDNotIn,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// is_applied field predicates
	IsApplied    *bool `json:"isApplied,omitempty"`
	IsAppliedNeq *bool `json:"isAppliedNEQ,omitempty"`
	// creator edge predicates
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
	// match_participation edge predicates
	HasMatchParticipation     *bool                      `json:"hasMatchParticipation,omitempty"`
	HasMatchParticipationWith []*ParticipationWhereInput `json:"hasMatchParticipationWith,omitempty"`
}

type Mutation struct {
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Participation struct {
	ID        string               `json:"id"`
	UserID    string               `json:"userID"`
	MatchID   string               `json:"matchID"`
	Status    participation.Status `json:"status"`
	CreatedAt time.Time            `json:"createdAt"`
	UpdatedAt time.Time            `json:"updatedAt"`
	User      *User                `json:"user"`
	Match     *Match               `json:"match"`
}

func (Participation) IsNode() {}

// ParticipationWhereInput is used for filtering Participation objects.
// Input was generated by ent.
type ParticipationWhereInput struct {
	Not *ParticipationWhereInput   `json:"not,omitempty"`
	And []*ParticipationWhereInput `json:"and,omitempty"`
	Or  []*ParticipationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// user_id field predicates
	UserID      *string  `json:"userID,omitempty"`
	UserIdneq   *string  `json:"userIDNEQ,omitempty"`
	UserIDIn    []string `json:"userIDIn,omitempty"`
	UserIDNotIn []string `json:"userIDNotIn,omitempty"`
	// match_id field predicates
	MatchID      *string  `json:"matchID,omitempty"`
	MatchIdneq   *string  `json:"matchIDNEQ,omitempty"`
	MatchIDIn    []string `json:"matchIDIn,omitempty"`
	MatchIDNotIn []string `json:"matchIDNotIn,omitempty"`
	// status field predicates
	Status      *participation.Status  `json:"status,omitempty"`
	StatusNeq   *participation.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []participation.Status `json:"statusIn,omitempty"`
	StatusNotIn []participation.Status `json:"statusNotIn,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// match edge predicates
	HasMatch     *bool              `json:"hasMatch,omitempty"`
	HasMatchWith []*MatchWhereInput `json:"hasMatchWith,omitempty"`
}

type Query struct {
}

// UpdateMatchInput is used for update Match object.
// Input was generated by ent.
type UpdateMatchInput struct {
	Title                       *string      `json:"title,omitempty"`
	Date                        *time.Time   `json:"date,omitempty"`
	Location                    *string      `json:"location,omitempty"`
	Level                       *match.Level `json:"level,omitempty"`
	Participants                *int32       `json:"participants,omitempty"`
	Fee                         *int32       `json:"fee,omitempty"`
	Notes                       *string      `json:"notes,omitempty"`
	UpdatedAt                   *time.Time   `json:"updatedAt,omitempty"`
	IsApplied                   *bool        `json:"isApplied,omitempty"`
	CreatorID                   *string      `json:"creatorID,omitempty"`
	AddMatchParticipationIDs    []string     `json:"addMatchParticipationIDs,omitempty"`
	RemoveMatchParticipationIDs []string     `json:"removeMatchParticipationIDs,omitempty"`
	ClearMatchParticipation     *bool        `json:"clearMatchParticipation,omitempty"`
}

// UpdateParticipationInput is used for update Participation object.
// Input was generated by ent.
type UpdateParticipationInput struct {
	Status    *participation.Status `json:"status,omitempty"`
	UpdatedAt *time.Time            `json:"updatedAt,omitempty"`
	UserID    *string               `json:"userID,omitempty"`
	MatchID   *string               `json:"matchID,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	Nickname                   *string    `json:"nickname,omitempty"`
	Email                      *string    `json:"email,omitempty"`
	PasswordHash               *string    `json:"passwordHash,omitempty"`
	Introduction               *string    `json:"introduction,omitempty"`
	UpdatedAt                  *time.Time `json:"updatedAt,omitempty"`
	AddMatchIDs                []string   `json:"addMatchIDs,omitempty"`
	RemoveMatchIDs             []string   `json:"removeMatchIDs,omitempty"`
	ClearMatches               *bool      `json:"clearMatches,omitempty"`
	AddUserParticipationIDs    []string   `json:"addUserParticipationIDs,omitempty"`
	RemoveUserParticipationIDs []string   `json:"removeUserParticipationIDs,omitempty"`
	ClearUserParticipation     *bool      `json:"clearUserParticipation,omitempty"`
}

type User struct {
	ID                string           `json:"id"`
	NickName          string           `json:"nickname"`
	Email             string           `json:"email"`
	PasswordHash      string           `json:"passwordHash"`
	Introduction      string           `json:"introduction"`
	CreatedAt         time.Time        `json:"createdAt"`
	UpdatedAt         time.Time        `json:"updatedAt"`
	Matches           []*Match         `json:"matches,omitempty"`
	UserParticipation []*Participation `json:"userParticipation,omitempty"`
}

func (User) IsNode() {}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// nickName field predicates
	Nickname             *string  `json:"nickname,omitempty"`
	NicknameNeq          *string  `json:"nicknameNEQ,omitempty"`
	NicknameIn           []string `json:"nicknameIn,omitempty"`
	NicknameNotIn        []string `json:"nicknameNotIn,omitempty"`
	NicknameGt           *string  `json:"nicknameGT,omitempty"`
	NicknameGte          *string  `json:"nicknameGTE,omitempty"`
	NicknameLt           *string  `json:"nicknameLT,omitempty"`
	NicknameLte          *string  `json:"nicknameLTE,omitempty"`
	NicknameContains     *string  `json:"nicknameContains,omitempty"`
	NicknameHasPrefix    *string  `json:"nicknameHasPrefix,omitempty"`
	NicknameHasSuffix    *string  `json:"nicknameHasSuffix,omitempty"`
	NicknameEqualFold    *string  `json:"nicknameEqualFold,omitempty"`
	NicknameContainsFold *string  `json:"nicknameContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// password_hash field predicates
	PasswordHash             *string  `json:"passwordHash,omitempty"`
	PasswordHashNeq          *string  `json:"passwordHashNEQ,omitempty"`
	PasswordHashIn           []string `json:"passwordHashIn,omitempty"`
	PasswordHashNotIn        []string `json:"passwordHashNotIn,omitempty"`
	PasswordHashGt           *string  `json:"passwordHashGT,omitempty"`
	PasswordHashGte          *string  `json:"passwordHashGTE,omitempty"`
	PasswordHashLt           *string  `json:"passwordHashLT,omitempty"`
	PasswordHashLte          *string  `json:"passwordHashLTE,omitempty"`
	PasswordHashContains     *string  `json:"passwordHashContains,omitempty"`
	PasswordHashHasPrefix    *string  `json:"passwordHashHasPrefix,omitempty"`
	PasswordHashHasSuffix    *string  `json:"passwordHashHasSuffix,omitempty"`
	PasswordHashEqualFold    *string  `json:"passwordHashEqualFold,omitempty"`
	PasswordHashContainsFold *string  `json:"passwordHashContainsFold,omitempty"`
	// introduction field predicates
	Introduction             *string  `json:"introduction,omitempty"`
	IntroductionNeq          *string  `json:"introductionNEQ,omitempty"`
	IntroductionIn           []string `json:"introductionIn,omitempty"`
	IntroductionNotIn        []string `json:"introductionNotIn,omitempty"`
	IntroductionGt           *string  `json:"introductionGT,omitempty"`
	IntroductionGte          *string  `json:"introductionGTE,omitempty"`
	IntroductionLt           *string  `json:"introductionLT,omitempty"`
	IntroductionLte          *string  `json:"introductionLTE,omitempty"`
	IntroductionContains     *string  `json:"introductionContains,omitempty"`
	IntroductionHasPrefix    *string  `json:"introductionHasPrefix,omitempty"`
	IntroductionHasSuffix    *string  `json:"introductionHasSuffix,omitempty"`
	IntroductionEqualFold    *string  `json:"introductionEqualFold,omitempty"`
	IntroductionContainsFold *string  `json:"introductionContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// matches edge predicates
	HasMatches     *bool              `json:"hasMatches,omitempty"`
	HasMatchesWith []*MatchWhereInput `json:"hasMatchesWith,omitempty"`
	// user_participation edge predicates
	HasUserParticipation     *bool                      `json:"hasUserParticipation,omitempty"`
	HasUserParticipationWith []*ParticipationWhereInput `json:"hasUserParticipationWith,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
