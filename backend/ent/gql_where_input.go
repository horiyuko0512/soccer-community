// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/horiyuko0512/soccer-community/ent/match"
	"github.com/horiyuko0512/soccer-community/ent/participation"
	"github.com/horiyuko0512/soccer-community/ent/predicate"
	"github.com/horiyuko0512/soccer-community/ent/user"
)

// MatchWhereInput represents a where input for filtering Match queries.
type MatchWhereInput struct {
	Predicates []predicate.Match  `json:"-"`
	Not        *MatchWhereInput   `json:"not,omitempty"`
	Or         []*MatchWhereInput `json:"or,omitempty"`
	And        []*MatchWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "start_at" field predicates.
	StartAt      *time.Time  `json:"startAt,omitempty"`
	StartAtNEQ   *time.Time  `json:"startAtNEQ,omitempty"`
	StartAtIn    []time.Time `json:"startAtIn,omitempty"`
	StartAtNotIn []time.Time `json:"startAtNotIn,omitempty"`
	StartAtGT    *time.Time  `json:"startAtGT,omitempty"`
	StartAtGTE   *time.Time  `json:"startAtGTE,omitempty"`
	StartAtLT    *time.Time  `json:"startAtLT,omitempty"`
	StartAtLTE   *time.Time  `json:"startAtLTE,omitempty"`

	// "end_at" field predicates.
	EndAt      *time.Time  `json:"endAt,omitempty"`
	EndAtNEQ   *time.Time  `json:"endAtNEQ,omitempty"`
	EndAtIn    []time.Time `json:"endAtIn,omitempty"`
	EndAtNotIn []time.Time `json:"endAtNotIn,omitempty"`
	EndAtGT    *time.Time  `json:"endAtGT,omitempty"`
	EndAtGTE   *time.Time  `json:"endAtGTE,omitempty"`
	EndAtLT    *time.Time  `json:"endAtLT,omitempty"`
	EndAtLTE   *time.Time  `json:"endAtLTE,omitempty"`

	// "location" field predicates.
	Location             *string  `json:"location,omitempty"`
	LocationNEQ          *string  `json:"locationNEQ,omitempty"`
	LocationIn           []string `json:"locationIn,omitempty"`
	LocationNotIn        []string `json:"locationNotIn,omitempty"`
	LocationGT           *string  `json:"locationGT,omitempty"`
	LocationGTE          *string  `json:"locationGTE,omitempty"`
	LocationLT           *string  `json:"locationLT,omitempty"`
	LocationLTE          *string  `json:"locationLTE,omitempty"`
	LocationContains     *string  `json:"locationContains,omitempty"`
	LocationHasPrefix    *string  `json:"locationHasPrefix,omitempty"`
	LocationHasSuffix    *string  `json:"locationHasSuffix,omitempty"`
	LocationEqualFold    *string  `json:"locationEqualFold,omitempty"`
	LocationContainsFold *string  `json:"locationContainsFold,omitempty"`

	// "level" field predicates.
	Level      *match.Level  `json:"level,omitempty"`
	LevelNEQ   *match.Level  `json:"levelNEQ,omitempty"`
	LevelIn    []match.Level `json:"levelIn,omitempty"`
	LevelNotIn []match.Level `json:"levelNotIn,omitempty"`

	// "participants" field predicates.
	Participants      *int  `json:"participants,omitempty"`
	ParticipantsNEQ   *int  `json:"participantsNEQ,omitempty"`
	ParticipantsIn    []int `json:"participantsIn,omitempty"`
	ParticipantsNotIn []int `json:"participantsNotIn,omitempty"`
	ParticipantsGT    *int  `json:"participantsGT,omitempty"`
	ParticipantsGTE   *int  `json:"participantsGTE,omitempty"`
	ParticipantsLT    *int  `json:"participantsLT,omitempty"`
	ParticipantsLTE   *int  `json:"participantsLTE,omitempty"`

	// "fee" field predicates.
	Fee      *int  `json:"fee,omitempty"`
	FeeNEQ   *int  `json:"feeNEQ,omitempty"`
	FeeIn    []int `json:"feeIn,omitempty"`
	FeeNotIn []int `json:"feeNotIn,omitempty"`
	FeeGT    *int  `json:"feeGT,omitempty"`
	FeeGTE   *int  `json:"feeGTE,omitempty"`
	FeeLT    *int  `json:"feeLT,omitempty"`
	FeeLTE   *int  `json:"feeLTE,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "creator_id" field predicates.
	CreatorID      *uuid.UUID  `json:"creatorID,omitempty"`
	CreatorIDNEQ   *uuid.UUID  `json:"creatorIDNEQ,omitempty"`
	CreatorIDIn    []uuid.UUID `json:"creatorIDIn,omitempty"`
	CreatorIDNotIn []uuid.UUID `json:"creatorIDNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_applied" field predicates.
	IsApplied    *bool `json:"isApplied,omitempty"`
	IsAppliedNEQ *bool `json:"isAppliedNEQ,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "match_participation" edge predicates.
	HasMatchParticipation     *bool                      `json:"hasMatchParticipation,omitempty"`
	HasMatchParticipationWith []*ParticipationWhereInput `json:"hasMatchParticipationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MatchWhereInput) AddPredicates(predicates ...predicate.Match) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MatchWhereInput filter on the MatchQuery builder.
func (i *MatchWhereInput) Filter(q *MatchQuery) (*MatchQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMatchWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMatchWhereInput is returned in case the MatchWhereInput is empty.
var ErrEmptyMatchWhereInput = errors.New("ent: empty predicate MatchWhereInput")

// P returns a predicate for filtering matches.
// An error is returned if the input is empty or invalid.
func (i *MatchWhereInput) P() (predicate.Match, error) {
	var predicates []predicate.Match
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, match.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Match, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, match.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Match, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, match.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, match.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, match.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, match.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, match.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, match.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, match.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, match.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, match.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, match.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, match.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, match.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, match.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, match.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, match.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, match.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, match.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, match.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, match.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, match.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, match.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, match.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.StartAt != nil {
		predicates = append(predicates, match.StartAtEQ(*i.StartAt))
	}
	if i.StartAtNEQ != nil {
		predicates = append(predicates, match.StartAtNEQ(*i.StartAtNEQ))
	}
	if len(i.StartAtIn) > 0 {
		predicates = append(predicates, match.StartAtIn(i.StartAtIn...))
	}
	if len(i.StartAtNotIn) > 0 {
		predicates = append(predicates, match.StartAtNotIn(i.StartAtNotIn...))
	}
	if i.StartAtGT != nil {
		predicates = append(predicates, match.StartAtGT(*i.StartAtGT))
	}
	if i.StartAtGTE != nil {
		predicates = append(predicates, match.StartAtGTE(*i.StartAtGTE))
	}
	if i.StartAtLT != nil {
		predicates = append(predicates, match.StartAtLT(*i.StartAtLT))
	}
	if i.StartAtLTE != nil {
		predicates = append(predicates, match.StartAtLTE(*i.StartAtLTE))
	}
	if i.EndAt != nil {
		predicates = append(predicates, match.EndAtEQ(*i.EndAt))
	}
	if i.EndAtNEQ != nil {
		predicates = append(predicates, match.EndAtNEQ(*i.EndAtNEQ))
	}
	if len(i.EndAtIn) > 0 {
		predicates = append(predicates, match.EndAtIn(i.EndAtIn...))
	}
	if len(i.EndAtNotIn) > 0 {
		predicates = append(predicates, match.EndAtNotIn(i.EndAtNotIn...))
	}
	if i.EndAtGT != nil {
		predicates = append(predicates, match.EndAtGT(*i.EndAtGT))
	}
	if i.EndAtGTE != nil {
		predicates = append(predicates, match.EndAtGTE(*i.EndAtGTE))
	}
	if i.EndAtLT != nil {
		predicates = append(predicates, match.EndAtLT(*i.EndAtLT))
	}
	if i.EndAtLTE != nil {
		predicates = append(predicates, match.EndAtLTE(*i.EndAtLTE))
	}
	if i.Location != nil {
		predicates = append(predicates, match.LocationEQ(*i.Location))
	}
	if i.LocationNEQ != nil {
		predicates = append(predicates, match.LocationNEQ(*i.LocationNEQ))
	}
	if len(i.LocationIn) > 0 {
		predicates = append(predicates, match.LocationIn(i.LocationIn...))
	}
	if len(i.LocationNotIn) > 0 {
		predicates = append(predicates, match.LocationNotIn(i.LocationNotIn...))
	}
	if i.LocationGT != nil {
		predicates = append(predicates, match.LocationGT(*i.LocationGT))
	}
	if i.LocationGTE != nil {
		predicates = append(predicates, match.LocationGTE(*i.LocationGTE))
	}
	if i.LocationLT != nil {
		predicates = append(predicates, match.LocationLT(*i.LocationLT))
	}
	if i.LocationLTE != nil {
		predicates = append(predicates, match.LocationLTE(*i.LocationLTE))
	}
	if i.LocationContains != nil {
		predicates = append(predicates, match.LocationContains(*i.LocationContains))
	}
	if i.LocationHasPrefix != nil {
		predicates = append(predicates, match.LocationHasPrefix(*i.LocationHasPrefix))
	}
	if i.LocationHasSuffix != nil {
		predicates = append(predicates, match.LocationHasSuffix(*i.LocationHasSuffix))
	}
	if i.LocationEqualFold != nil {
		predicates = append(predicates, match.LocationEqualFold(*i.LocationEqualFold))
	}
	if i.LocationContainsFold != nil {
		predicates = append(predicates, match.LocationContainsFold(*i.LocationContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, match.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, match.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, match.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, match.LevelNotIn(i.LevelNotIn...))
	}
	if i.Participants != nil {
		predicates = append(predicates, match.ParticipantsEQ(*i.Participants))
	}
	if i.ParticipantsNEQ != nil {
		predicates = append(predicates, match.ParticipantsNEQ(*i.ParticipantsNEQ))
	}
	if len(i.ParticipantsIn) > 0 {
		predicates = append(predicates, match.ParticipantsIn(i.ParticipantsIn...))
	}
	if len(i.ParticipantsNotIn) > 0 {
		predicates = append(predicates, match.ParticipantsNotIn(i.ParticipantsNotIn...))
	}
	if i.ParticipantsGT != nil {
		predicates = append(predicates, match.ParticipantsGT(*i.ParticipantsGT))
	}
	if i.ParticipantsGTE != nil {
		predicates = append(predicates, match.ParticipantsGTE(*i.ParticipantsGTE))
	}
	if i.ParticipantsLT != nil {
		predicates = append(predicates, match.ParticipantsLT(*i.ParticipantsLT))
	}
	if i.ParticipantsLTE != nil {
		predicates = append(predicates, match.ParticipantsLTE(*i.ParticipantsLTE))
	}
	if i.Fee != nil {
		predicates = append(predicates, match.FeeEQ(*i.Fee))
	}
	if i.FeeNEQ != nil {
		predicates = append(predicates, match.FeeNEQ(*i.FeeNEQ))
	}
	if len(i.FeeIn) > 0 {
		predicates = append(predicates, match.FeeIn(i.FeeIn...))
	}
	if len(i.FeeNotIn) > 0 {
		predicates = append(predicates, match.FeeNotIn(i.FeeNotIn...))
	}
	if i.FeeGT != nil {
		predicates = append(predicates, match.FeeGT(*i.FeeGT))
	}
	if i.FeeGTE != nil {
		predicates = append(predicates, match.FeeGTE(*i.FeeGTE))
	}
	if i.FeeLT != nil {
		predicates = append(predicates, match.FeeLT(*i.FeeLT))
	}
	if i.FeeLTE != nil {
		predicates = append(predicates, match.FeeLTE(*i.FeeLTE))
	}
	if i.Notes != nil {
		predicates = append(predicates, match.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, match.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, match.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, match.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, match.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, match.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, match.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, match.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, match.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, match.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, match.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, match.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, match.NotesContainsFold(*i.NotesContainsFold))
	}
	if i.CreatorID != nil {
		predicates = append(predicates, match.CreatorIDEQ(*i.CreatorID))
	}
	if i.CreatorIDNEQ != nil {
		predicates = append(predicates, match.CreatorIDNEQ(*i.CreatorIDNEQ))
	}
	if len(i.CreatorIDIn) > 0 {
		predicates = append(predicates, match.CreatorIDIn(i.CreatorIDIn...))
	}
	if len(i.CreatorIDNotIn) > 0 {
		predicates = append(predicates, match.CreatorIDNotIn(i.CreatorIDNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, match.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, match.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, match.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, match.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, match.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, match.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, match.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, match.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, match.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, match.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, match.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, match.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, match.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, match.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, match.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, match.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsApplied != nil {
		predicates = append(predicates, match.IsAppliedEQ(*i.IsApplied))
	}
	if i.IsAppliedNEQ != nil {
		predicates = append(predicates, match.IsAppliedNEQ(*i.IsAppliedNEQ))
	}

	if i.HasCreator != nil {
		p := match.HasCreator()
		if !*i.HasCreator {
			p = match.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, match.HasCreatorWith(with...))
	}
	if i.HasMatchParticipation != nil {
		p := match.HasMatchParticipation()
		if !*i.HasMatchParticipation {
			p = match.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMatchParticipationWith) > 0 {
		with := make([]predicate.Participation, 0, len(i.HasMatchParticipationWith))
		for _, w := range i.HasMatchParticipationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMatchParticipationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, match.HasMatchParticipationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMatchWhereInput
	case 1:
		return predicates[0], nil
	default:
		return match.And(predicates...), nil
	}
}

// ParticipationWhereInput represents a where input for filtering Participation queries.
type ParticipationWhereInput struct {
	Predicates []predicate.Participation  `json:"-"`
	Not        *ParticipationWhereInput   `json:"not,omitempty"`
	Or         []*ParticipationWhereInput `json:"or,omitempty"`
	And        []*ParticipationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *uuid.UUID  `json:"userID,omitempty"`
	UserIDNEQ   *uuid.UUID  `json:"userIDNEQ,omitempty"`
	UserIDIn    []uuid.UUID `json:"userIDIn,omitempty"`
	UserIDNotIn []uuid.UUID `json:"userIDNotIn,omitempty"`

	// "match_id" field predicates.
	MatchID      *uuid.UUID  `json:"matchID,omitempty"`
	MatchIDNEQ   *uuid.UUID  `json:"matchIDNEQ,omitempty"`
	MatchIDIn    []uuid.UUID `json:"matchIDIn,omitempty"`
	MatchIDNotIn []uuid.UUID `json:"matchIDNotIn,omitempty"`

	// "status" field predicates.
	Status      *participation.Status  `json:"status,omitempty"`
	StatusNEQ   *participation.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []participation.Status `json:"statusIn,omitempty"`
	StatusNotIn []participation.Status `json:"statusNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "match" edge predicates.
	HasMatch     *bool              `json:"hasMatch,omitempty"`
	HasMatchWith []*MatchWhereInput `json:"hasMatchWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParticipationWhereInput) AddPredicates(predicates ...predicate.Participation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParticipationWhereInput filter on the ParticipationQuery builder.
func (i *ParticipationWhereInput) Filter(q *ParticipationQuery) (*ParticipationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParticipationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParticipationWhereInput is returned in case the ParticipationWhereInput is empty.
var ErrEmptyParticipationWhereInput = errors.New("ent: empty predicate ParticipationWhereInput")

// P returns a predicate for filtering participations.
// An error is returned if the input is empty or invalid.
func (i *ParticipationWhereInput) P() (predicate.Participation, error) {
	var predicates []predicate.Participation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, participation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Participation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, participation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Participation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, participation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, participation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, participation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, participation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, participation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, participation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, participation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, participation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, participation.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, participation.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, participation.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, participation.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, participation.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.MatchID != nil {
		predicates = append(predicates, participation.MatchIDEQ(*i.MatchID))
	}
	if i.MatchIDNEQ != nil {
		predicates = append(predicates, participation.MatchIDNEQ(*i.MatchIDNEQ))
	}
	if len(i.MatchIDIn) > 0 {
		predicates = append(predicates, participation.MatchIDIn(i.MatchIDIn...))
	}
	if len(i.MatchIDNotIn) > 0 {
		predicates = append(predicates, participation.MatchIDNotIn(i.MatchIDNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, participation.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, participation.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, participation.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, participation.StatusNotIn(i.StatusNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, participation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, participation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, participation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, participation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, participation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, participation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, participation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, participation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, participation.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, participation.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, participation.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, participation.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, participation.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, participation.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, participation.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, participation.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasUser != nil {
		p := participation.HasUser()
		if !*i.HasUser {
			p = participation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, participation.HasUserWith(with...))
	}
	if i.HasMatch != nil {
		p := participation.HasMatch()
		if !*i.HasMatch {
			p = participation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMatchWith) > 0 {
		with := make([]predicate.Match, 0, len(i.HasMatchWith))
		for _, w := range i.HasMatchWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMatchWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, participation.HasMatchWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParticipationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return participation.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "nickName" field predicates.
	NickName             *string  `json:"nickname,omitempty"`
	NickNameNEQ          *string  `json:"nicknameNEQ,omitempty"`
	NickNameIn           []string `json:"nicknameIn,omitempty"`
	NickNameNotIn        []string `json:"nicknameNotIn,omitempty"`
	NickNameGT           *string  `json:"nicknameGT,omitempty"`
	NickNameGTE          *string  `json:"nicknameGTE,omitempty"`
	NickNameLT           *string  `json:"nicknameLT,omitempty"`
	NickNameLTE          *string  `json:"nicknameLTE,omitempty"`
	NickNameContains     *string  `json:"nicknameContains,omitempty"`
	NickNameHasPrefix    *string  `json:"nicknameHasPrefix,omitempty"`
	NickNameHasSuffix    *string  `json:"nicknameHasSuffix,omitempty"`
	NickNameEqualFold    *string  `json:"nicknameEqualFold,omitempty"`
	NickNameContainsFold *string  `json:"nicknameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password_hash" field predicates.
	PasswordHash             *string  `json:"passwordHash,omitempty"`
	PasswordHashNEQ          *string  `json:"passwordHashNEQ,omitempty"`
	PasswordHashIn           []string `json:"passwordHashIn,omitempty"`
	PasswordHashNotIn        []string `json:"passwordHashNotIn,omitempty"`
	PasswordHashGT           *string  `json:"passwordHashGT,omitempty"`
	PasswordHashGTE          *string  `json:"passwordHashGTE,omitempty"`
	PasswordHashLT           *string  `json:"passwordHashLT,omitempty"`
	PasswordHashLTE          *string  `json:"passwordHashLTE,omitempty"`
	PasswordHashContains     *string  `json:"passwordHashContains,omitempty"`
	PasswordHashHasPrefix    *string  `json:"passwordHashHasPrefix,omitempty"`
	PasswordHashHasSuffix    *string  `json:"passwordHashHasSuffix,omitempty"`
	PasswordHashEqualFold    *string  `json:"passwordHashEqualFold,omitempty"`
	PasswordHashContainsFold *string  `json:"passwordHashContainsFold,omitempty"`

	// "introduction" field predicates.
	Introduction             *string  `json:"introduction,omitempty"`
	IntroductionNEQ          *string  `json:"introductionNEQ,omitempty"`
	IntroductionIn           []string `json:"introductionIn,omitempty"`
	IntroductionNotIn        []string `json:"introductionNotIn,omitempty"`
	IntroductionGT           *string  `json:"introductionGT,omitempty"`
	IntroductionGTE          *string  `json:"introductionGTE,omitempty"`
	IntroductionLT           *string  `json:"introductionLT,omitempty"`
	IntroductionLTE          *string  `json:"introductionLTE,omitempty"`
	IntroductionContains     *string  `json:"introductionContains,omitempty"`
	IntroductionHasPrefix    *string  `json:"introductionHasPrefix,omitempty"`
	IntroductionHasSuffix    *string  `json:"introductionHasSuffix,omitempty"`
	IntroductionEqualFold    *string  `json:"introductionEqualFold,omitempty"`
	IntroductionContainsFold *string  `json:"introductionContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "refresh_token" field predicates.
	RefreshToken             *string  `json:"refreshToken,omitempty"`
	RefreshTokenNEQ          *string  `json:"refreshTokenNEQ,omitempty"`
	RefreshTokenIn           []string `json:"refreshTokenIn,omitempty"`
	RefreshTokenNotIn        []string `json:"refreshTokenNotIn,omitempty"`
	RefreshTokenGT           *string  `json:"refreshTokenGT,omitempty"`
	RefreshTokenGTE          *string  `json:"refreshTokenGTE,omitempty"`
	RefreshTokenLT           *string  `json:"refreshTokenLT,omitempty"`
	RefreshTokenLTE          *string  `json:"refreshTokenLTE,omitempty"`
	RefreshTokenContains     *string  `json:"refreshTokenContains,omitempty"`
	RefreshTokenHasPrefix    *string  `json:"refreshTokenHasPrefix,omitempty"`
	RefreshTokenHasSuffix    *string  `json:"refreshTokenHasSuffix,omitempty"`
	RefreshTokenIsNil        bool     `json:"refreshTokenIsNil,omitempty"`
	RefreshTokenNotNil       bool     `json:"refreshTokenNotNil,omitempty"`
	RefreshTokenEqualFold    *string  `json:"refreshTokenEqualFold,omitempty"`
	RefreshTokenContainsFold *string  `json:"refreshTokenContainsFold,omitempty"`

	// "matches" edge predicates.
	HasMatches     *bool              `json:"hasMatches,omitempty"`
	HasMatchesWith []*MatchWhereInput `json:"hasMatchesWith,omitempty"`

	// "user_participation" edge predicates.
	HasUserParticipation     *bool                      `json:"hasUserParticipation,omitempty"`
	HasUserParticipationWith []*ParticipationWhereInput `json:"hasUserParticipationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.NickName != nil {
		predicates = append(predicates, user.NickNameEQ(*i.NickName))
	}
	if i.NickNameNEQ != nil {
		predicates = append(predicates, user.NickNameNEQ(*i.NickNameNEQ))
	}
	if len(i.NickNameIn) > 0 {
		predicates = append(predicates, user.NickNameIn(i.NickNameIn...))
	}
	if len(i.NickNameNotIn) > 0 {
		predicates = append(predicates, user.NickNameNotIn(i.NickNameNotIn...))
	}
	if i.NickNameGT != nil {
		predicates = append(predicates, user.NickNameGT(*i.NickNameGT))
	}
	if i.NickNameGTE != nil {
		predicates = append(predicates, user.NickNameGTE(*i.NickNameGTE))
	}
	if i.NickNameLT != nil {
		predicates = append(predicates, user.NickNameLT(*i.NickNameLT))
	}
	if i.NickNameLTE != nil {
		predicates = append(predicates, user.NickNameLTE(*i.NickNameLTE))
	}
	if i.NickNameContains != nil {
		predicates = append(predicates, user.NickNameContains(*i.NickNameContains))
	}
	if i.NickNameHasPrefix != nil {
		predicates = append(predicates, user.NickNameHasPrefix(*i.NickNameHasPrefix))
	}
	if i.NickNameHasSuffix != nil {
		predicates = append(predicates, user.NickNameHasSuffix(*i.NickNameHasSuffix))
	}
	if i.NickNameEqualFold != nil {
		predicates = append(predicates, user.NickNameEqualFold(*i.NickNameEqualFold))
	}
	if i.NickNameContainsFold != nil {
		predicates = append(predicates, user.NickNameContainsFold(*i.NickNameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PasswordHash != nil {
		predicates = append(predicates, user.PasswordHashEQ(*i.PasswordHash))
	}
	if i.PasswordHashNEQ != nil {
		predicates = append(predicates, user.PasswordHashNEQ(*i.PasswordHashNEQ))
	}
	if len(i.PasswordHashIn) > 0 {
		predicates = append(predicates, user.PasswordHashIn(i.PasswordHashIn...))
	}
	if len(i.PasswordHashNotIn) > 0 {
		predicates = append(predicates, user.PasswordHashNotIn(i.PasswordHashNotIn...))
	}
	if i.PasswordHashGT != nil {
		predicates = append(predicates, user.PasswordHashGT(*i.PasswordHashGT))
	}
	if i.PasswordHashGTE != nil {
		predicates = append(predicates, user.PasswordHashGTE(*i.PasswordHashGTE))
	}
	if i.PasswordHashLT != nil {
		predicates = append(predicates, user.PasswordHashLT(*i.PasswordHashLT))
	}
	if i.PasswordHashLTE != nil {
		predicates = append(predicates, user.PasswordHashLTE(*i.PasswordHashLTE))
	}
	if i.PasswordHashContains != nil {
		predicates = append(predicates, user.PasswordHashContains(*i.PasswordHashContains))
	}
	if i.PasswordHashHasPrefix != nil {
		predicates = append(predicates, user.PasswordHashHasPrefix(*i.PasswordHashHasPrefix))
	}
	if i.PasswordHashHasSuffix != nil {
		predicates = append(predicates, user.PasswordHashHasSuffix(*i.PasswordHashHasSuffix))
	}
	if i.PasswordHashEqualFold != nil {
		predicates = append(predicates, user.PasswordHashEqualFold(*i.PasswordHashEqualFold))
	}
	if i.PasswordHashContainsFold != nil {
		predicates = append(predicates, user.PasswordHashContainsFold(*i.PasswordHashContainsFold))
	}
	if i.Introduction != nil {
		predicates = append(predicates, user.IntroductionEQ(*i.Introduction))
	}
	if i.IntroductionNEQ != nil {
		predicates = append(predicates, user.IntroductionNEQ(*i.IntroductionNEQ))
	}
	if len(i.IntroductionIn) > 0 {
		predicates = append(predicates, user.IntroductionIn(i.IntroductionIn...))
	}
	if len(i.IntroductionNotIn) > 0 {
		predicates = append(predicates, user.IntroductionNotIn(i.IntroductionNotIn...))
	}
	if i.IntroductionGT != nil {
		predicates = append(predicates, user.IntroductionGT(*i.IntroductionGT))
	}
	if i.IntroductionGTE != nil {
		predicates = append(predicates, user.IntroductionGTE(*i.IntroductionGTE))
	}
	if i.IntroductionLT != nil {
		predicates = append(predicates, user.IntroductionLT(*i.IntroductionLT))
	}
	if i.IntroductionLTE != nil {
		predicates = append(predicates, user.IntroductionLTE(*i.IntroductionLTE))
	}
	if i.IntroductionContains != nil {
		predicates = append(predicates, user.IntroductionContains(*i.IntroductionContains))
	}
	if i.IntroductionHasPrefix != nil {
		predicates = append(predicates, user.IntroductionHasPrefix(*i.IntroductionHasPrefix))
	}
	if i.IntroductionHasSuffix != nil {
		predicates = append(predicates, user.IntroductionHasSuffix(*i.IntroductionHasSuffix))
	}
	if i.IntroductionEqualFold != nil {
		predicates = append(predicates, user.IntroductionEqualFold(*i.IntroductionEqualFold))
	}
	if i.IntroductionContainsFold != nil {
		predicates = append(predicates, user.IntroductionContainsFold(*i.IntroductionContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.RefreshToken != nil {
		predicates = append(predicates, user.RefreshTokenEQ(*i.RefreshToken))
	}
	if i.RefreshTokenNEQ != nil {
		predicates = append(predicates, user.RefreshTokenNEQ(*i.RefreshTokenNEQ))
	}
	if len(i.RefreshTokenIn) > 0 {
		predicates = append(predicates, user.RefreshTokenIn(i.RefreshTokenIn...))
	}
	if len(i.RefreshTokenNotIn) > 0 {
		predicates = append(predicates, user.RefreshTokenNotIn(i.RefreshTokenNotIn...))
	}
	if i.RefreshTokenGT != nil {
		predicates = append(predicates, user.RefreshTokenGT(*i.RefreshTokenGT))
	}
	if i.RefreshTokenGTE != nil {
		predicates = append(predicates, user.RefreshTokenGTE(*i.RefreshTokenGTE))
	}
	if i.RefreshTokenLT != nil {
		predicates = append(predicates, user.RefreshTokenLT(*i.RefreshTokenLT))
	}
	if i.RefreshTokenLTE != nil {
		predicates = append(predicates, user.RefreshTokenLTE(*i.RefreshTokenLTE))
	}
	if i.RefreshTokenContains != nil {
		predicates = append(predicates, user.RefreshTokenContains(*i.RefreshTokenContains))
	}
	if i.RefreshTokenHasPrefix != nil {
		predicates = append(predicates, user.RefreshTokenHasPrefix(*i.RefreshTokenHasPrefix))
	}
	if i.RefreshTokenHasSuffix != nil {
		predicates = append(predicates, user.RefreshTokenHasSuffix(*i.RefreshTokenHasSuffix))
	}
	if i.RefreshTokenIsNil {
		predicates = append(predicates, user.RefreshTokenIsNil())
	}
	if i.RefreshTokenNotNil {
		predicates = append(predicates, user.RefreshTokenNotNil())
	}
	if i.RefreshTokenEqualFold != nil {
		predicates = append(predicates, user.RefreshTokenEqualFold(*i.RefreshTokenEqualFold))
	}
	if i.RefreshTokenContainsFold != nil {
		predicates = append(predicates, user.RefreshTokenContainsFold(*i.RefreshTokenContainsFold))
	}

	if i.HasMatches != nil {
		p := user.HasMatches()
		if !*i.HasMatches {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMatchesWith) > 0 {
		with := make([]predicate.Match, 0, len(i.HasMatchesWith))
		for _, w := range i.HasMatchesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMatchesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasMatchesWith(with...))
	}
	if i.HasUserParticipation != nil {
		p := user.HasUserParticipation()
		if !*i.HasUserParticipation {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserParticipationWith) > 0 {
		with := make([]predicate.Participation, 0, len(i.HasUserParticipationWith))
		for _, w := range i.HasUserParticipationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserParticipationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUserParticipationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
